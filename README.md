Project: binomial_queue
==============

# Теоретическая часть #

Организация биномиальных куч(очередей) имеет схожую природу с организацией хранения данных в виде массива куч, который мы использовали в реализации плавной сортировки, только здесь все проще. 

Главное предназначение биномиальных куч в том, что их можно объединять за логарифмическое время. Как показывает практика такая задача практически не встречается в чистом виде, но зато может быть использована как подзадача в более сложной задаче. 

## Добавление элемента в биномиальную кучу ##
Эта операция полностью повторяет логику сложения двух двоичных чисел. Допустим нам нужно сложить 11 и 1.

        1011 
     +  0001  
     -------  
        1100

Единичный разряд будет переноситься до ближайшего справа нулевого бита. Функция добавления нового элемента может выглядеть вот так:

~~~
void
bheap_add( bheap_t *h, pair_t v ) {
    if( h->size + 1 >= h->data_size ) {
        h->data_size *= 2;
        h->data = (pair_t*) realloc( h->data, h->data_size * sizeof(pair_t) );
    }
    h->data[ ++(h->size) ] = v ;
    bheap_checkup( h, h->size );
}
~~~

## Поиск максимального элемента в биномиальной куче ##
Корень каждого пирамидального дерева является максимальным элементов в данном дереве. Поэтому для поиска максимального элемента в биномиальной куче нужно последовательно перебрать все корни пирамидальных деревьев и выбрать максимальный. 


# Инструкция по компиляции #

Запуск под терминалом
~~~
$ cd ~/Projects
$ git init
$ git clone git://github.com/rtridz/binomial_queue.git
$ cd ./binomial_queue/
$ gcc main.cpp -o binomial_queue
$ binomial_queue
~~~
на худой конец копируем код в вашу VisualStudio и радуемся

# Инструкцию по использованию #

После запуска
~~~
$ binomial_queue
~~~
вводим элементы кучи (занечения могут быть любые отличные от нуля)
нуль считается завершающим символом конца строки и после него элементы считываться не будут

~~~
Кол-во эл-ов кучи: 14 12 17 18 2 7 3 0

2 3 7 12 14 17 18 
~~~

Можно заметиь что выводом являются отсортированные элементы кучи.

# Краткое описание логики и оценка сложности алгоритмов программы #
1) Создать пустую кучу.
Алгоритм: создаем пустой объект bheap_t *h
Сложность: очевидно, время работы O(1).
2) Вставить новый элемент в кучу.
Алгоритм: Создаем кучу из одного элемента и объединяем с нашей кучей.
Сложность: O(1) + O(log(n)) = O(log(n)).
3) Найти минимум в куче.
Алгоритм: очевидно, минимум находится в корневом списке, то есть, чтобы его найти нужно пройтись по корневому списку.
Сложность: O(log(n)).

# Список литературы #

* J.W.J. Williams, Algorithm 232, Heapsort, CACM 7, 6 (June 1964), 347–348.
* R.W. Floyd, Algorithm 245, Treesort 3, CACM 7, 12 (Dec. 1964), 701.
* Vuillemin, J. A data structure for manipulating priority queues. СACM 21 (1978), 309–314.
* Р.Седжвик. Алгоритмы на С++: Пер. с англ. – М.: ООО «И.Д. Вильямс», 2011 – 1056 с.
* Fredman, M. L.; Tarjan (1987). Fibonacci heaps and their uses in improved network optimization algorithms. СACM 34 (3): 596–615.
* Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн. Алгоритмы: построение и анализ — 2-е изд. — М.: Издательский дом «Вильямс», 2007. — С. 1296.
* К.Д.Маннинг, П.Рагхаван, Х.Шютце. Введение в информационный поиск. - “Вильямс”. 2011.
